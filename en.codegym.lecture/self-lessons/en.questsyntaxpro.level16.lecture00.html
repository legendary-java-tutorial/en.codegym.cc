Ensuring compatibility in Java
<p>----------------------------------------</p>
History of the versions of Java. Java's history begins in 1991, when a group of Sun programmers decided to create a language for small devices: TV remote controls, coffee makers, toasters, bank cards, and so on. Manufacturers of these devices used very different processors to control...
<p>----------------------------------------</p>
<h2>1. History of the versions of Java</h2>
<p>Java's history begins in 1991, when <span class="text-viola">a group of Sun programmers decided to create a language for small devices:</span> TV remote controls, coffee makers, toasters, bank cards, and so on.</p>
<p>Manufacturers of these devices used very different processors to control their products, so it became very important to be tied to the architecture of a particular processor or OS.</p>
<p>Java's creators decided to break the problem into two parts: <span class="text-green">Their programs would be compiled not into the machine code for a specific processor, but into a special intermediate code.</span> In turn, that intermediate code would be executed by a special program called a <span class="term">virtual machine</span>.</p>
<p><span class="text-red">Most programmers refer to a computer as a machine.</span></p>
<div class="lesson-note lesson-note--info">
    <div class="lesson-note__container">
        <div class="lesson-note__head">Interesting.</div>
        <div class="lesson-note__content">
            <p>C++ was taken as the basis for Java language and was greatly simplified and standardized. If C++ let you do something 10 ways, then Java retained only one of them. In some ways it was like the transition from hieroglyphs to an alphabet.</p>
        </div>
    </div>
</div>
<p>The first version of Java was released in 1996. Since that time, Java began its triumphant march around the world, which, in turn, stimulated the evolution and growth of the language itself. Today, millions of libraries and billions of lines of code are written in Java, and new versions of Java are released every 6 months:</p>
<table>
    <tbody>
    <tr>
        <th>Name</th>
        <th>Year</th>
        <th>Number of classes</th>
    </tr>
    <tr>
        <td><strong>JDK 1.0</strong></td>
        <td>1996</td>
        <td>211</td>
    </tr>
    <tr>
        <td><strong>JDK 1.1</strong></td>
        <td>1997</td>
        <td>477</td>
    </tr>
    <tr>
        <td><strong><span class="text-red">J2SE 1.2</span></strong></td>
        <td>1998</td>
        <td>1,524</td>
    </tr>
    <tr>
        <td><strong>J2SE 1.3</strong></td>
        <td>2000</td>
        <td>1,840</td>
    </tr>
    <tr>
        <td><strong>J2SE 1.4</strong></td>
        <td>2002</td>
        <td>2,723</td>
    </tr>
    <tr>
        <td><strong><span class="text-red">J2SE 5.0</span></strong></td>
        <td>2004</td>
        <td>3,279</td>
    </tr>
    <tr>
        <td><strong>Java SE 6</strong></td>
        <td>2006</td>
        <td>3,793</td>
    </tr>
    <tr>
        <td><strong>Java SE 7</strong></td>
        <td>2011</td>
        <td>4,024</td>
    </tr>
    <tr>
        <td><strong><span class="text-red">Java SE 8</span></strong></td>
        <td>2014</td>
        <td>4,240</td>
    </tr>
    <tr>
        <td><strong>Java SE 9</strong></td>
        <td>2017</td>
        <td>6,005</td>
    </tr>
    <tr>
        <td><strong>Java SE 10</strong></td>
        <td>2018</td>
        <td>6,002</td>
    </tr>
    <tr>
        <td><strong><span class="text-red">Java SE 11</span></strong></td>
        <td>2018</td>
        <td>4,411</td>
    </tr>
    <tr>
        <td><strong>Java SE 12</strong></td>
        <td>2019</td>
        <td>4,433</td>
    </tr>
    <tr>
        <td><strong>Java SE 13</strong></td>
        <td>2019</td>
        <td>4,515</td>
    </tr>
    </tbody>
</table>
<p>Although versions of Java were released regularly, they did not all carry equal significance for programmers: Java has evolved in fits and starts.</p>
<hr>
<h2>2. Java 2</h2>
<p>The first big leap forward occurred with the release of JDK 1.2. It had so many innovations there that Java's creators renamed it <span class="text-viola">Java 2 Platform Standard Edition</span> or J2SE 1.2 for short.</p>
<p>The main innovations were:</p>
<ul>
    <li><code>strictfp</code> keyword</li>
    <li>The Swing library for working with graphics</li>
    <li>The JIT compiler, which accelerated execution of Java programs</li>
    <li>A huge set of collections</li>
    <li>Full Unicode support: Japanese, Chinese and Korean.</li>
</ul>
<p>Today, these innovations do not seem so big, but every big project grows out of a small one. Java wouldn't be as popular today if a small group of programmers hadn't kept improving the language 20 years ago.</p>
<hr>
<h2>3. Java 5</h2>
<p>JDK 1.5 was released in September 2004. It also introduced a lot of innovations, so it couldn't help but deserve a new name: instead of versions 1.5, 1.6, and 1.7, they decided to use 5.0, 6.0, and 7.0. So, the full name of JDK 1.5 was <strong>Java 2 Standard Edition 5.0</strong></p>
<p>This update included things without which the language's further development would not have been possible.</p>
<p><span class="text-bold">Annotations</span>. Half of the major modern frameworks are built on annotations, from Spring and Hibernate to JUnit.</p>
<p><span class="text-bold">Generics</span>. Generics have taken the power of collections (and much more) to new heights. The code has become simpler, more compact and safer.</p>
<p><span class="text-bold">Autoboxing/unboxing</span> is automatic conversion between primitive types and their wrapper types. This made it much easier to write and read code, and made collections even more popular.</p>
<p>The <span class="text-bold"><code>foreach</code> loop</span> now accounts for at least half of all loops that programmers write. And, of course, it is indispensable when working with collections.</p>
<p>The <span class="text-bold">enum</span> is another nice new feature. It allows many things to be beautifully simplified.</p>
<p>These are not all the innovations: hundreds of new classes were added. The important thing is that they were just the right innovations, and gave another powerful boost to Java's popularity.</p>
<hr>
<h2>4. Java 6</h2>
<p>Java 6 is remembered for a large number of small improvements and the abandonment of the number 2 in the name: it was no longer "Java 2 Standard Edition 6.0", but simply "Java Standard Edition 6.0".</p>
<p>Here are some of the interesting innovations:</p>
<p>The <span class="term">Java Compiler API</span> made it possible to call the <span class="term">Java compiler</span> directly from the code. That means your program could now generate text representing class code, compile it by calling methods of the <span class="term">Java Compiler API</span>, and then immediately start calling the methods of the compiled class. There are whole areas of development where this ability greatly simplifies life.</p>
<p>It became possible to execute <strong>JavaScript</strong> directly inside a Java program. This feature appeared because JavaSE 6 included the Rhino JavaScript engine.</p>
<hr>
<h2>5. Java 7</h2>
<p>Java 7 was released in July 2011. There were supposed to be many improvements in it, but the programmers only managed to add a small part of what was planned. In particular, they added things like:</p>
<p><strong>A new library for working with data input and output.</strong> Known as the <span class="term">New Input Output API</span>, it is located in the <code>java.nio</code> package.</p>
<p>The Java compiler's <strong>automatic type inference</strong> at compile time let programmers write less code. The compiler got smarter, and that was just the beginning.</p>
<p>The switch statement gained the ability to use strings as case values.</p>
<p>Automatic resource management also improved significantly: With the <code>try-with-resources</code> construct, a Java program can close data streams for you when they are no longer needed.</p>
<p>There were many other changes, but they are not so important at our current stage of learning Java.</p>
<hr>
<h2>6. Java 8</h2>
<p>Java 8 came out in March 2014 and was Java's strongest recent update.</p>
<p>Above all, programmers remember it for its addition of lambda expressions and functional interfaces (the <code>@FunctionalInterface</code> annotation). We will examine them at Level 21. Your code will never be the same again.</p>
<p>Streams were also added for collections, which, in combination with lambda expressions, made it possible to write code much more compactly. Although not always much more readable.</p>
<p> </p>
<div class="lesson-note lesson-note--info">
    <div class="lesson-note__container">
        <div class="lesson-note__head">Interesting.</div>
        <div class="lesson-note__content">
            <p>And the third big change was Java 8's introduction of a whole new API for working with dates and times — the <strong>Date Time API</strong>. We'll study it in the near future.</p>
        </div>
    </div>
</div>
<hr>
<h2>7. Java 9</h2>
<p>Java 9 was released in September 2017. From that time, Java's creators have decided to release new versions more frequently — every six months. They were probably impressed by the approach adopted by the developers of the Google Chrome browser.</p>
<p>The Java 9 release focused more on the internals of the Java machine. The most significant thing it brought to ordinary programmers was the ability to divide a program into modules. This is very convenient when you have tens of thousands of classes or when your code dynamically unloads plugins.</p>
<p>But it will probably be of little use to us in the near future.</p>
<hr>
<h2>8. Java 11</h2>
<p>Six months after the release of Java 9, Java 10 came out, and another six months later, Java 11 came out.</p>
<p>A lot of small improvements were made during this time, but you will mostly likely remember only two:</p>
<p><strong>It added support for Unicode 10.</strong> Now you can use emojis in your Java programs. You can work with them in the same way that you work with the boolean type:</p>
<p>Type inference was improved, and the <strong><code>var</code> keyword</strong>, which you are sure to like, appeared.</p>
<p>Now you can write the following:</p>
<pre class="language-java"><code>var str = "Hello";</code></pre>
<p>And the compiler converts this to:</p>
<pre class="language-java"><code>String str = "Hello";</code></pre>
<p>But there were also some losses. Java's creators dropped libraries such as JavaFX, Java EE, and CORBA from JDK 11.</p>
<hr>
<h2>9. Importance of compatibility</h2>
<p>When a new version is released, programmers quite often want to start from scratch. After all, who wants to fix a bunch of old bugs when they are absolutely positive how the code should have been written from the very beginning?</p>
<p>But history doesn't support such an approach. Every time programmers release a new version of a program, 90% of its users are using an old version. They can use or ignore the program's new features, but what users hate is when <span class="text-red">something that used to work well stops working.</span></p>
<p>Many great products have died when programmers released new versions that were not compatible. Or simply when they made major changes. For example, the idea of abandoning the Start button in Windows 8 did not appeal to users. The release of Windows 10 brought back half of what was removed in Window 8.</p>
<p>What's more, Windows lets you run programs written 20 years ago for Windows 95 or even written 30 years ago for MS DOS 3.0 — they will work. This is one of the reasons why Windows remains popular.</p>
<p>And Java wouldn't be as popular as it is if its developers didn't care about compatibility. Any time there is a new version of the Java machine, a new version of the SDK, or major changes to classes, <strong>all the Java code written since January 1996 continues to work.</strong></p>
<p><span class="text-green">This is usually achieved by only adding new methods, classes, and packages, without removing anything.</span> This approach has its pros and cons.</p>
<p>On the one hand, Java drags around a bunch of baggage in the form of old, suboptimal, and unnecessary code. On the other hand, your project written in Java 11 can always use a library written in Java 8 that uses libraries written in Java 5 and Java 2. This hodgepodge of code will work just fine.</p>
<p>With the C++ language, libraries compiled for both 32-bit and 64-bit platforms cannot be used in the same project. And you'll have a huge headache if you suddenly discover that the <code>char</code> type used in one library uses one byte, while another uses two bytes.</p>
<hr>
<h2>10. Deprecated</h2>
<p>So, Java's creators decided not to remove anything, but only to add new classes and packages. But how do they let programmers know that there is a new worthy alternative to an existing suboptimal solution?</p>
<p>To do this, they came up with the <code><span class="text-orange">@Deprecated</span></code> annotation.</p>
<p>If some method or class is deprecated, this annotation is added next to its declaration. It means that programmers are discouraged from using the code.</p>
<p>You can still use a deprecated class or method, but it is not recommended.</p>
<p>And how often do people do things that are not recommended? Almost always 🙂</p>
<p>Many classes have been deprecated for 20 years — they have been used and are still being used. People are familiar with them or they are just convenient. But there is a risk that they will be removed at some point, so it is better not to use them.</p>
<p>All modern IDEs, including IntelliJ IDEA, can handle the <code><span class="text-orange">@Deprecated</span></code> annotation. The names of deprecated classes and methods are displayed using <span class="text-red"><s>strikethrough</s></span> formatting. Something like this:</p>
<div class="lesson-example lesson-example--center">
        <pre class="lecture-code lecture-code--present language-java"><code>Date <span class="text-green">date</span> = new Date();
int <span class="text-user">day</span> = <span class="text-green">date</span>.<span class="text-red"><s>getDay</s></span>();</code></pre>
</div>
<p>Deprecated classes are very popular and often found in code, so we will look at some of them soon.</p>