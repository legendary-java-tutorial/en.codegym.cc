Tips on using collections
<p>----------------------------------------</p>
As you may remember, Java has collections — a handy tool for storing objects of the same type. Let's try to recall the main collection-related interfaces...
<p>----------------------------------------</p>
<h2>1. List of collections</h2>

    <p>As you may remember, Java has collections — a handy tool for storing objects of the same type.</p>

    <p>Let's try to recall the main collection-related interfaces:</p>

    <p><span class="text-neon"><span class="text-bold">List</span></span>, <span class="text-neon"><span class="text-bold">Set</span></span>, <span class="text-neon"><span class="text-bold">Map</span></span> and <span class="text-neon"><span class="text-bold">Queue</span></span>.</p>

    <p>As usual, tools aren't necessarily good or bad — what matters is whether you are using them for their intended purpose. And to do that, we must thoroughly understand their specific features in order to know which collection to use and when.</p>

    <h3>1. List</h3>

    <p>Let's start with the most used collection.</p>

    <p><span class="text-neon"><span class="text-bold">List</span></span> as close as possible to a plain old array. </p>

    <p>This collection lets us conveniently store a list of objects of the same type without worrying about the size of the collection itself, as we would have to if we were using an array. Elements of the collection are accessed by index. If we know exactly where an object is and need to access it frequently without often needing to add or remove elements, a <span class="text-neon"><span class="text-bold">List</span></span> is ideal.</p>

    <h3>2. Set</h3>

    <p><span class="text-neon"><span class="text-bold">Set</span></span> has a completely different structure.</p>

    <p><span class="text-neon"><span class="text-bold">Set</span></span> is most suitable when we need to store unique objects. For example, a set of authors in a library where each author is unique. But we can't just go and grab any specific author from it. <span class="text-neon"><span class="text-bold">Set</span></span> lets us quickly check whether a particular author is present in our library, i.e. we can check whether a unique object is present in a <span class="text-neon"><span class="text-bold">Set</span></span>. We can also iterate over the entire collection, accessing each element, but doing that is not optimal.</p>

    <p>In other words, for our library, a <span class="text-neon"><span class="text-bold">Set</span></span> can represent the collection of all unique authors to quickly check if any particular author is present. </p>

    <h3>3. Map</h3>

    <p><span class="text-neon"><span class="text-bold">Map</span></span> is more like a filing cabinet, where each file is signed and can store individual objects or entire structures. <span class="text-neon"><span class="text-bold">Map</span></span> should be used in cases where we need to maintaining a mapping from one value to another.</p>

    <p>For <span class="text-neon"><span class="text-bold">Map</span></span>, these relationships are called key-value pairs.</p>

    <p>We could use this structure in our library by using author objects as the keys and lists (<span class="text-neon"><span class="text-bold">List</span></span> objects) of books as the values. Thus, after checking a <span class="text-neon"><span class="text-bold">Set</span></span> to see if an author object exists in the library, we can use the same author object to get a <span class="text-neon"><span class="text-bold">List</span></span> of his or her books from a <span class="text-neon"><span class="text-bold">Map</span></span>. </p>

    <h3>4. Queue</h3>

    <p><span class="text-neon"><span class="text-bold">Queue</span></span> is a collection that — surprise! — implements the behavior of a queue. And the queue can be either <span class="text-bold">LIFO</span> (Last In, First Out) or <span class="text-bold">FIFO</span> (First In, First Out). What's more, the queue can be bidirectional, or "doubled-ended".</p>

    <p>This structure is helpful when the objects added to the class need to be used in the order they are received. For example, take our library.</p>

    <p>We can add newly arrived visitors to a <span class="text-neon"><span class="text-bold">Queue</span></span> and serve them in turn, issuing the books they come for.</p>

    <p>As we can see, each of these structures is good if used for its intended purpose. And we found good uses for all four types of collections in a single library example.</p>

    <h2>2. Complexity</h2>

    <p>As already noted, the collections we considered above are interfaces, which means they must have implementations in order for us to use them.</p>

    <p>Just as hammering nails with a microscope is not the best idea, not every implementation of a collection is suited to every situation. </p>

    <p>When choosing the right tool for a job, we typically look at 2 characteristics:</p>

    <ul>
        <li>How well does the tool fit the job?</li>
        <li>How fast will it get the job done?</li>
    </ul>

    <p>We've spent some time figuring out how to choose a suitable tool for a job, but its speed is something new.</p>

    <p>In computing, a tool's speed is often expressed in terms of time complexity and denoted by a capital letter O.</p>

    <p>What in the world is time complexity?</p>

    <p>In simple terms, time complexity indicates the time required for an algorithm in the collection to perform a particular action (adding/removing an element, searching for an element).</p>

    <h3>ArrayList vs LinkedList</h3>

    <p>Let's look at this using two implementations of the <span class="text-neon"><span class="text-bold">List</span></span> interface — <span class="text-bold"><span class="text-red">ArrayList</span></span> and <span class="text-bold"><span class="text-red">LinkedList</span></span>.</p>

    <p>For outward appearances, working with these collections is similar:</p>

    <pre class='language-java line-numbers'><code>
List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();
arrayList.add(String);
arrayList.get(index);
arrayList.remove(index);
arrayList.remove(String);
 
List&lt;String&gt; linkedList = new LinkedList&lt;&gt;();
 
linkedList.add(String);
 
linkedList.get(index);
linkedList.remove(index);
linkedList.remove(String);
    </code></pre>
 
    <p>As you can see, for both collection types, adding, getting, and removing elements looks the same. This is because these are implementations on the same interface. But that's where the similarities end.</p>

    <p>Due to their different implementations of the <span class="text-neon"><span class="text-bold">List</span></span> interface, these two structures perform different actions more efficiently than others.</p>

    <p>Consider removing and adding an element.</p>

    <p>If we need to remove an element from the middle of an <span class="text-bold"><span class="text-red">ArrayList</span></span>, we have to overwrite whatever part of the list follows the element we remove.</p>

    <p>Suppose we have a list of 5 elements and we want to remove the 3rd one.</p>

    <pre class='language-java line-numbers'><code>
List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);
list.remove(2);
    </code></pre>

    <p>In this case, the removal frees up one cell, so we need to write the 4th element where the 3rd was, and the 5th where the 4th was.</p>
 
    <img src="https://cdn.codegym.cc/images/article/b6fd4afa-b68d-4353-922c-98768517752e/original.png" alt="">

    <p>This is highly inefficient.</p>

    <p>The same happens when adding an element to the middle of the list.</p>

    <img src="https://cdn.codegym.cc/images/article/183f3aee-230e-452d-a18e-043baadd4eba/original.png" alt="">

    <p>LinkedList is structured differently. Adding or removing elements is fast, since we only need to change the references in the previous and next elements, thereby excluding the object we are removing from the chain of elements.</p>

    <p>Returning to the example of the same list of 5 elements, after removing the 3rd element, all we need to do is simply change the 2nd element's reference to the next element and 4th element's reference to the previous one.</p>
 
    <img src="https://cdn.codegym.cc/images/article/dd10b7d4-7006-4117-87bf-b3348010ba88/original.png" alt="">

    <p>When an element is added to the list, the same process happens, but in reverse.</p>

    <p>Notice how much less work we need to do in a <span class="text-bold"><span class="text-red">LinkedList</span></span> compared to an <span class="text-bold"><span class="text-red">ArrayList</span></span>. And that's just 5 elements. If our list had 100 or more elements, the superiority of <span class="text-bold"><span class="text-red">LinkedList</span></span> would become even more noticeable. </p>

    <p>But how does the situation change if we access an element by index?</p>

    <p>Everything is the exact opposite here.</p>

    <p>Since ArrayList</span></span> is structured as an ordinary array, getting any element by its index will be very easy for us. We simply move the pointer to a certain place and get the element from the corresponding cell.</p>

    <p>But a <span class="text-bold"><span class="text-red">LinkedList</span></span> simply doesn't work that way. We have to go through all the elements of the list to find the element with a certain index. </p>

    <p>Shall we try to express all of this in terms of big O?</p>

    <p>Let's start by accessing an element by index.</p>

    <p>In an <span class="text-bold"><span class="text-red">ArrayList</span></span>, this happens in one step, regardless of where the element is located in the list. Whether at the end or the beginning.</p>

    <p>In this case, the time complexity will be <span class="text-bold">O(1)</span>.</p>

    <p>In a <span class="text-bold"><span class="text-red">LinkedList</span></span>, we have to iterate over a number of elements equal to the value of the index we need.</p>

    <p>The time complexity for such an action is <span class="text-bold">O(n)</span>, where n is the index of the element we need.</p>

    <p>Here you see that the number we put in the big-O parentheses corresponds to the number of actions performed.</p>

    <p>Shell we return to removing and adding?</p>

    <p><span class="text-bold">Let's start with LinkedList.</span></p>

    <p>Because we do not need to do a large number of actions to add or remove an element, and the speed of this operation does not depend in any way on where the element is located, it complexity is expressed as <span class="text-bold">O(1)</span> and is said to be constant.</p>

    <p>The time complexity of this operation for <span class="text-bold"><span class="text-red">ArrayList</span></span> is also <span class="text-bold">O(n)</span>, which we call linear complexity.</p>

    <p>In algorithms with linear complexity, the running time depends directly on the number of elements to be processed. It may also depend on the element's position, whether it is at the beginning of the list or towards the end.</p>

    <p>Time complexity can also be logarithmic. This is expressed as <span class="text-bold">O(log n)</span>.</p>

    <p>As an example, consider a sorted <span class="text-bold"><span class="text-red">TreeSet</span></span> consisting of 10 numbers. We want to find the number 2.</p>

    <p>Since the list is sorted and contains no duplicates, we can split it in half and check which half would contain the desired number, discard the irrelevant part and then repeat this process until we reach the desired element. Ultimately, we will find (or not find) the number after processing log(n) number of elements.</p>

    <p>Here's a table that summarizes the time complexity the rest of the collections.</p>
 
    <table>
        <tbody>
            <tr>
                <th></th>
                <th>By index</th>
                <th>By key</th>
                <th>Search</th>
                <th>Insertion at the end</th>
                <th>Insertion in the end</th>
                <th>Removal</th>
            </tr>

            <tr>
                <th>ArrayList</th>
                <td>O(1)</td>
                <td>N/A</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>

            <tr>
                <th>LinkedList</th>
                <td>O(n)</td>
                <td>N/A</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>HashSet</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>TreeSet</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(log n)</td>
                <td>N/A</td>
                <td>O(log n)</td>
                <td>O(log n)</td>
            </tr>

            <tr>
                <th>HashMap</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>

            <tr>
                <th>TreeMap</th>
                <td>N/A</td>
                <td>O(1)</td>
                <td>O(log n)</td>
                <td>N/A</td>
                <td>O(log n)</td>
                <td>O(log n)</td>
            </tr>

            <tr>
                <th>ArrayDeque</th>
                <td>N/A</td>
                <td>N/A</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
        <tbody>
    </table>

    <p>Now that we have a table showing the time complexity of popular collections, we can answer the question why, out of so many collections, we most often use <span class="text-bold"><span class="text-red">ArrayList</span></span>, <span class="text-neon"><span class="text-bold">HashSet</span></span> and <span class="text-neon"><span class="text-bold">HashMap</span></span>.</p>

    <p>It's simply that they are the most efficient for most tasks :)</p>