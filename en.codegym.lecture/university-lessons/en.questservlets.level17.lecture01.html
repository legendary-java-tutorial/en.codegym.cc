Behavioral patterns, part 2
<p>----------------------------------------</p>
State Strategy Template Method Chain of Responsibility Memento
<p>----------------------------------------</p>
is a behavioral design pattern. It is used in those cases when, during the execution of the program, the object must change its behavior depending on its state.</p>
<img data-max-width="800" data-id="0b64173f-b514-4ae1-a073-6cbb386a5716" src="https://cdn.codegym.cc/images/article/0b64173f-b514-4ae1-a073-6cbb386a5716/800.jpeg" alt="">
<p>The pattern consists of 3 blocks:</p>
<p>Context is a class whose objects should change their behavior depending on the state.</p>
<p>State is the interface that each of the concrete states must implement. Through this interface, the Context object interacts with the state by delegating method calls to it. The interface should contain means for feedback to the object whose behavior is to be changed.</p>
<p>For this, <strong>an event</strong> is used (pattern Publisher - Subscriber). This is necessary in order to replace the state object during the execution of the program when events occur. There may be cases where the Context itself periodically polls the state object for a transition.</p>
<p>ConcreteState1, ConcreteState2 - classes of concrete states. Should contain information on under what conditions and in what states the object can pass from the current state. For example, from ConcreteState1, an object can go to ConcreteState2 and ConcreteState3, and from ConcreteState2 back to ConcreteState1, and so on. The object of one of them must contain the Context when created.</p>
<p>For example, you are writing a game where a character can run, swim and fly. If your character got into the water, then it is reasonable to limit his behavior in the water: now he cannot shoot, but he still has some actions: swim forward, right, left, etc.</p>
<p>The state of your character can be described by a State object, which has methods that can be called and that will do something. And after your character got into the water, you just change the reference to another State object inside it - and it changes its state.</p>
<h2>2.2 strategy</h2>
<p><strong>Strategy</strong> is a behavioral design pattern for defining a family of algorithms, encapsulating each one, and making them interchangeable. This allows you to choose an algorithm by defining the appropriate class.</p>
<p>The Strategy pattern allows you to change the selected algorithm regardless of the client objects that use it.</p>
<img data-max-width="800" data-id="673c4c44-ec33-4d4e-860f-399abc388d8d" src="https://cdn.codegym.cc/images/article/673c4c44-ec33-4d4e-860f-399abc388d8d/800.jpeg" alt="">
<p>The Strategy pattern allows you to use different business rules or algorithms depending on the context. It is used in cases where different algorithms must be used in the same place depending on the current state of the system (or its environment).</p>
<p><strong>Strengths:</strong></p>
<ul>
 <li>encapsulation of the implementation of various algorithms, the system becomes independent of possible changes in business rules;</li>
 <li>calling all algorithms in one standard way;</li>
 <li>not using switches and/or conditional statements.</li>
</ul>
<p>This pattern is somewhat similar to the State pattern, but here the emphasis is not on the state, but on the behavior. Let's say a character in your game can change weapons. Then when changing weapons, you can simply change the reference to the object that describes how this weapon works.</p>
<h2>2.3 Template Method</h2>
<img data-max-width="800" data-id="be4df3de-e667-4f4d-9ea7-d3b021879bb2" src="https://cdn.codegym.cc/images/article/be4df3de-e667-4f4d-9ea7-d3b021879bb2/800.jpeg" alt="">
<p><strong>Abstract class</strong> (abstract class) - defines the abstract operations that are replaced in the heirs to implement the steps of the algorithm; implements a template method that defines the skeleton of the algorithm. The template method calls the replaced and other operations defined in the Abstract class.</p>
<p><strong>Concrete class</strong> (concrete class) - implements the replaced operations in the way necessary for implementation. The Concrete class assumes that the invariant steps of the algorithm will be performed in the AbstractClass.</p>
<p>This pattern is often used when needed:</p>
<ul>
 <li>Single use of the invariant part of the algorithm, leaving the changing part at the discretion of the heirs.</li>
 <li>Localization and isolation of code common to several classes to avoid duplication.</li>
 <li>Allow inheritors to extend code only in certain places.</li>
</ul>
<p>Yes, this pattern describes the use of a pair: an abstract class and its implementation.</p>
<h2>2.4 Chain of Responsibility</h2>
<p><strong>Chain of responsibility</strong> is a behavioral design pattern designed to organize levels of responsibility in a system.</p>
<img data-max-width="800" data-id="41b55822-dc67-4db3-a0e8-b467bc9f320d" src="https://cdn.codegym.cc/images/article/41b55822-dc67-4db3-a0e8-b467bc9f320d/800.jpeg" alt="">
<p>The template is recommended for use in conditions where:</p>
<ul>
 <li>in the developed system there is a group of objects that can process messages of a certain type;</li>
 <li>all messages must be processed by at least one system object;</li>
 <li>messages in the system are processed according to the “process it yourself or pass it on to another” scheme, that is, some messages are processed at the level where they were received, while others are forwarded to objects of another level.</li>
</ul>
<h2>2.5 Memento</h2>
<p><strong>Keeper (Memento)</strong> is a behavioral design pattern that allows you to fix and save the internal state of an object without violating encapsulation so that it can be restored to this state later.</p>
<img data-max-width="800" data-id="9b1d2d68-74b7-427c-8d7b-cf44640cf51f" src="https://cdn.codegym.cc/images/article/9b1d2d68-74b7-427c-8d7b-cf44640cf51f/800.jpeg" alt="">
<p>The Guardian pattern is used when:</p>
<ul>
 <li>it is necessary to save a snapshot of the state of the object (or part of it) for subsequent restoration;</li>
 <li>The direct interface for getting the state of an object exposes implementation details and breaks object encapsulation.</li>
</ul>