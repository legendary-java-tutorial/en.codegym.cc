Aliases
<p>----------------------------------------</p>
Change the column names. Table aliases. primary key.
<p>----------------------------------------</p>
<h2>Changing column names</h2>
<p>We also need to deal with the column names. Otherwise, we repeat the names name and id, but they contain different data. On the other hand, there is the first id column and the employee_id column, which contain the same data.</p>
<p>Let's write a query, where there will be only the necessary columns, and also rename the columns with the same names:</p>
<pre><code><span class="text-red"><span class="text-bold">SELECT  
    <span class="text-orange">task</span>.<span class="text-green">id</span> AS <span class="text-viola">task_id</span>,  
    <span class="text-orange">task</span>.<span class="text-green">name</span> AS <span class="text-viola">task_desc</span>, 
    <span class="text-orange">task</span>.<span class="text-green">deadline</span> AS <span class="text-viola">deadline</span>, 
    <span class="text-orange">emploee</span>.<span class="text-green">id</span> AS <span class="text-viola">emploee_id</span>,  
    <span class="text-orange">emploee</span>.<span class="text-green">name</span> AS <span class="text-viola">emp_name</span>,  
<span class="text-orange">emploee</span>.<span class="text-green">occupation</span> AS	
    <span class="text-viola">emp_occupation</span> 
FROM <span class="text-orange">employee</span>, <span class="text-orange">task</span>
WHERE <span class="text-orange">emploee</span>.<span class="text-green">id</span> = <span class="text-orange">task</span>.<span class="text-green">emploee_id</span></span>
</span></code></pre>
<p>And the result of this query:</p>
<div class="table-container">
 <table>
  <tbody>
   <tr>
    <th>task_id</th>
    <th>task_desc</th>
    <th>deadline</th>
    <th>emploee_id</th>
    <th>emp_name</th>
    <th>emp_occupation</th>
   </tr>
   <tr>
    <td>1</td>
    <td>Fix a bug on the frontend</td>
    <td>2022-06-01</td>
    <td>1</td>
    <td>Ivanov Ivan</td>
    <td>Programmer</td>
   </tr>
   <tr>
    <td>2</td>
    <td>Fix a bug on the backend</td>
    <td>2022-06-15</td>
    <td>2</td>
    <td>Petrov Petr</td>
    <td>Programmer</td>
   </tr>
   <tr>
    <td>7</td>
    <td>Enjoy life</td>
    <td>(NULL)</td>
    <td>4</td>
    <td>Rabinovich Moisha</td>
    <td>Director</td>
   </tr>
   <tr>
    <td>3</td>
    <td>Buy coffee</td>
    <td>2022-07-01</td>
    <td>5</td>
    <td>Kirienko Anastasia</td>
    <td>Office Manager</td>
   </tr>
   <tr>
    <td>4</td>
    <td>Buy coffee</td>
    <td>2022-08-01</td>
    <td>5</td>
    <td>Kirienko Anastasia</td>
    <td>Office Manager</td>
   </tr>
   <tr>
    <td>5</td>
    <td>Buy coffee</td>
    <td>2022-09-01</td>
    <td>5</td>
    <td>Kirienko Anastasia</td>
    <td>Office Manager</td>
   </tr>
   <tr>
    <td>8</td>
    <td>Enjoy life</td>
    <td>(NULL)</td>
    <td>6</td>
    <td>Vaska</td>
    <td>cat</td>
   </tr>
  </tbody>
 </table>
</div>
<p>Great, the problem with incomprehensible column names has been successfully solved. The query has become a bit long, but everything is clear in the resulting table. And no extra columns.</p>
<h2>Table aliases</h2>
<p>Sometimes table names are too long and take up a lot of space in the query. Therefore, the creators of SQL, to improve readability, as in the case of columns, offered the ability to specify table aliases.</p>
<p>The general form of aliases (table aliases) is as follows:</p>
<pre><code><span class="text-bold"><span class="text-red">FROM</span> <span class="text-orange">table1 alias1</span>, <span class="text-orange">table2 alias2</span></span>
</code></pre>
<p>Let's rewrite our previous query with short aliases:</p>
<pre><code><span class="text-bold"><span class="text-red">SELECT</span>  
    <span class="text-orange">t</span>.<span class="text-green">id</span> <span class="text-red">AS</span> <span class="text-viola">task_id</span>,  
    <span class="text-orange">t</span>.<span class="text-green">name</span> <span class="text-red">AS</span> <span class="text-viola">task_desc</span>, 
    <span class="text-orange">t</span>.<span class="text-green">deadline</span> <span class="text-red">AS</span> <span class="text-viola">deadline</span>, 
    <span class="text-orange">e</span>.<span class="text-green">id</span> <span class="text-red">AS</span> <span class="text-viola">emploee_id</span>,  
    <span class="text-orange">e</span>.<span class="text-green">name</span> <span class="text-red">AS</span> <span class="text-viola">emp_name</span>,  
    <span class="text-orange">e</span>.<span class="text-green">occupation</span> <span class="text-red">AS</span> <span class="text-viola">emp_occupation </span>
    <span class="text-red">FROM</span> <span class="text-orange">employee e</span>, <span class="text-orange">task t </span>
<span class="text-red">WHERE</span> <span class="text-orange">e</span>.<span class="text-green">id = <span class="text-orange">t</span>.<span class="text-green">emploee_id</span>
</span></span></code></pre>
<p>Readability has decreased slightly, but this is because the names of the tables were initially simple and clear. It might as well be like this:</p>
<pre><code><span class="text-bold"><span class="text-red">SELECT</span>  
  	<span class="text-orange">task</span>.<span class="text-green">id</span> <span class="text-red">AS</span> <span class="text-viola">task_id</span>,  
  	<span class="text-orange">task</span>.<span class="text-green">name</span> <span class="text-red">AS</span> <span class="text-viola">task_desc</span>, 
  	<span class="text-orange">task</span>.<span class="text-green">deadline</span> <span class="text-red">AS</span> <span class="text-viola">deadline</span>, 
  	<span class="text-orange">emploee</span>.<span class="text-green">id</span> <span class="text-red">AS</span> <span class="text-viola">emploee_id</span>,  
  	<span class="text-orange">emploee</span>.<span class="text-green">name</span> <span class="text-red">AS</span> <span class="text-viola">emp_name</span>,  
<span class="text-orange">emploee</span>.<span class="text-green">occupatio</span>n <span class="text-red">AS</span>	
  	<span class="text-viola">emp_occupation </span>
<span class="text-red">FROM  </span>
  	<span class="text-orange">Microsoft_it_department_employee employee</span>, 
  	<span class="text-orange">Year2022_priority_task task</span> 
<span class="text-red">WHERE</span> <span class="text-orange">emploee</span>.<span class="text-green">id</span> = <span class="text-orange">task</span>.<span class="text-green">emploee_id</span> </span>
</code></pre>
<p>And in this case, aliases are already useful, right? ;)</p>
<h2>primary key</h2>
<p>And one more important information about tables. Remember that we had an employee_id column in the task table? With it, we referenced the employee ID from the employee table.</p>
<p>If we want to refer from one table to the rows of another table, then the referenced table must have a column with an ID, which is also called the primary key - <span class="text-user">PRIMARY KEY</span> .</p>
<p>Most often, this is a specially added column whose value type is <span class="text-orange">int</span> . When adding records to a table, SQL automatically sets the value of this column.</p>
<p>Then a lot of things are tied to these keys:</p>
<ul>
 <li>linking different tables to each other;</li>
 <li>quick search and filtering by id;</li>
 <li>data integrity in the database (no references to non-existent id);</li>
 <li>deleting data that no one refers to;</li>
 <li>and many many others.</li>
</ul>
<p>By the way, there are situations when a table has a so-called <strong>natural key</strong> . This is when there is a column whose contents imply uniqueness. For example, we decided to add to the employee table:</p>
<ul>
 <li>The order of their arrival in the company;</li>
 <li>Tax number;</li>
 <li>Number and series of the passport.</li>
</ul>
<p>Sometimes database designers use a natural key as the primary key, but most often they are used separately. After all, records can be deleted, changed, and the like.</p>
<p>I suppose you read stories on the Internet when bailiffs hang debts of his full namesake on a person? This is just related to the concept of a unique key. It is very convenient for banks and bailiffs to search for a person by full name and year of birth. And in 99% of cases this is enough to identify a person.</p>
<p>But the remaining &lt;1% are full namesakes, with the same year of birth. In the life of each of us, there are most likely no such people, but on a national scale, there are. In general, if you are writing software or designing a database, then it is useful to know that this can also be the case.</p>