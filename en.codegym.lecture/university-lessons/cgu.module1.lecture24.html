SortedMap
<p>----------------------------------------</p>
In this lesson, we'll study the SortedMap interface. We'll explore new methods that appear in this interface, as well as the features of one implementation of SortedMap — TreeMap — and the differences between implementations...
<p>----------------------------------------</p>
<h2>SortedMap</h2>

    <p>In this lesson, we'll study the <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> interface. We'll explore new methods that appear in this interface, as well as the features of one implementation of <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> — <span class="code text-green"><span class="text-bold">TreeMap</span></span> — and the differences between implementations, as well as their advantages compared to <span class="code text-green"><span class="text-bold">HashMap</span></span>.</p>

    <p>Let's see what the hierarchy of maps looks like. Pay special attention to the <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> interface and its <span class="code text-green"><span class="text-bold">TreeMap</span></span> implementation — they are our focus today:</p>

    <img data-max-width="512" data-id="260d3b98-c06b-47ca-be55-b5f3372eb010" src="https://cdn.codegym.cc/images/article/260d3b98-c06b-47ca-be55-b5f3372eb010/original.png" alt="">

    <p>The <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> interface extends the <span class="text-neon"><span class="text-bold"><em>Map</em></span></span> interface. In many ways, it is similar to <span class="text-neon"><span class="text-bold"><em>SortedSet</em></span></span> (which in turn extends <span class="text-neon"><span class="text-bold"><em>Set</em></span></span>), since they both describe similar functionality for storing and using sorted values. </p>

    <p><span class="text-neon"><span class="text-bold"><em>SortedSet</em></span></span> works with and stores <span class="code">&lt;TValue&gt;</span> objects, but SortedMap</em></span></span> stores <span class="code">&lt;TKey, TValue&gt;</span> pairs. It's a map that stores all its elements in ascending order of their keys.</p>

    <p>The <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> interface extends <span class="text-neon"><span class="text-bold"><em>Map</em></span></span>. It adds the following methods:</p>

    <table>
        <tbody>
            <tr>
                <th>Method</th><th>Description</th>
            </tr>
            <tr>
                <td><span class="code text-orange">TKey firstKey()</span></td>
                <td>Returns the key of the first element of the map</td>
            </tr>
            <tr>
                <td><span class="code text-orange">TKey lastKey()</span></td>
                <td>Returns the key of the last element of the map</td>
            </tr>
            <tr>
                <td><span class="code text-orange">SortedMap&lt;TKey, TValue&gt; headMap(TKey end)</span></td>
                <td>Returns a <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> that contains all the elements of the original <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> up to and including the element with the key <span class="text-user">end</span></td>
            </tr>
            <tr>
                <td><span class="code text-orange">SortedMap&lt;TKey, Tvalue&gt; tailMap(K start)</span></td>
                <td>Returns a <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> that contains all the elements of the original <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, starting at the element with key <span class="text-user">start</span> (inclusive)</td>
            </tr>
            <tr>
                <td><span class="code text-orange">SortedMap&lt;TKey, TValue&gt; subMap(TKey start, TKey end)</span></td>
                <td>Returns a <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> that contains all the elements of the original <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>, from the element with key <span class="text-user">start</span> to the element with key <span class="text-user">end</span> (not including <span class="text-user">end)</td>
            </tr>
        </tbody>
    </table>

    <h2>TreeMap class</h2>

    <p>The <span class="code"><span class="text-green">TreeMap</span></span> class is an implementation of the <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> interface. That is, <span class="code"><span class="text-green">TreeMap</span></span> implements all the methods added by <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> as well as the standard ones from the <span class="text-neon"><span class="text-bold"><em>Map</em></span></span> interface.</p>

    <p>You can create a <span class="code"><span class="text-green">TreeMap</span></span> object using constructors like these:</p>

    <ul>
        <li><p><span class="code text-orange">TreeMap()</span>: creates an empty map implemented as a tree;</li></p>
        <li><p><span class="code text-orange">TreeMap(Map&lt;? extends TKey, ? extends TValue&gt; map)</span>: creates a tree and adds all the elements from the input map;</li></p>
        <li><p><span class="code text-orange">TreeMap(SortedMap&lt;TKey, ? extends TValue&gt; smap)</span>: creates a tree and adds all elements from the input sorted map;</li></p>
        <li><p><span class="code text-orange">TreeMap(Comparator&lt;? super TKey&gt; comparator)</span>: creates an empty tree — the comparator will be used to sort all elements as they are subsequently added.</li></p>
    </ul>

    <p>Here <em>TKey</em> is the type of the keys in the stored pairs, and <em>TValue</em> is the type of the values in the pairs stored in the <span class="code text-green"><span class="text-bold">TreeMap</span></span>.</p>

    <p><span class="text-neon"><span class="text-bold"><em>Comparator</em></span></span> is pretty important for <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>/<span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span>. It establishes the rules for sorting — or ordering — our map. If we don't provide a comparator, then the natural ordering of our keys will be used when we create a <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>.</p>

    <h3>Adding elements to a TreeMap</h3>

    <p>Elements are added to a map as pairs using the <span class="code text-orange">put()</span> method. The key is passed as the first argument, and the value is passed as the second. For example, suppose we want to create a list of students and their grades.</p>

    <pre class='language-java line-numbers'><code>
SortedMap&lt;String, Integer&gt; map =new TreeMap &lt;String,Integer&gt;();

map.put("Anthony", 5);
map.put("Sara", 5);
map.put("Roxy", 5);
map.put("Jeff", 4);
map.put("Nick", 4);
map.put("Oliver", 3);
map.put("Oliver", 5);

System.out.println(map);
</code></pre>

    <p>Result: </p>

    <div class="terminal">{Anthony=5, Nick=4, Oliver=5, Roxy=5, Sara=5, Jeff=4}</div>

    <p>When we add a key-value pair, if the key already exists in the collection, then the old value is replaced by the new value. This behavior is illustrated in our example with two pairs that have the same key — <span class="text-bold">("Oliver", 3)</span> and <span class="text-bold">("Oliver", 5)</span>.</p>

    <p>Let's look at an example with a <span class="text-neon"><span class="text-bold"><em>Comparator</em></span></span> that we create. Suppose we want to store the elements sorted by the length of the key string. If the length of the keys is equal, then we will sort alphabetically (the natural ordering of strings): </p>

    <pre class='language-java line-numbers'><code>
class LengthComparator implements Comparator&lt;String&gt; {
  public int compare(String o1, String o2) {
    Integer lenghComparedResult = Integer.compare(o1.length(), o2.length());
    return lenghComparedResult != 0 ? lenghComparedResult : o1.compareTo(o2);
  }
}

SortedMap&lt;String, Integer&gt; lengthComparedMap = new TreeMap&lt;String, Integer&gt;(new LengthComparator());

lengthComparedMap.put("Jeff", 4);
lengthComparedMap.put("Oliver", 5);
lengthComparedMap.put("Roxy", 4);
lengthComaredMap.put("Jan", 4);
</code></pre>

    <p>Here's the resulting sequence:</p>

    <div class="terminal">lengthComparedMap: {Jan=4, Jeff=4, Roxy=4, Oliver=5}</div>

    <p>This behavior makes a <span class="code text-green"><span class="text-bold">TreeMap</span></span> like a sorted array or list whose indices are words (<span class="text-orange">String</span>) instead of numbers.</p>

    <table>
        <tbody>
            <tr>
                <td>It's important to note that almost any type can be the KeyType or ValueType. There are some small additional requirements for the KeyType, and you will learn about them when you study collections in greater detail.</td>
            </tr>
        </tbody>
    </table>

    <h2>SortedMap methods in the TreeMap class</h2>

    <ol>

        <li>
            <p>If you need to get the key of the first student, you can use the <span class="code text-orange">firstKey()</span> method:</p>

            <pre class='language-java line-numbers'><code>
String firstKey = map.firstKey();
	System.out.println("First key → " + firstKey);
</code></pre>

            <p>Result: <span class="code">First key → Anthony</span></p>
        </li>

        <li>
                <p>If you need to get the key of the last student, you can use the <span class="code text-orange">lastKey()</span> method:</p>

            <pre class='language-java line-numbers'><code>
String lastKey = map.lastKey();
System.out.println("Last key → " + lastKey);
</code></pre>

            <p>Result: <span class="code">Last Key → Jeff</span></p>
        </li>

        <li>
            <p>Get all objects that come after the object with the key "<em>Sara</em>":</p>

<pre class='language-java line-numbers'><code>
Map&lt;String, Integer&gt; tailMap = map.tailMap("Sara");
         	System.out.println("tailMap: " + tailMap);
</code></pre>

            <p>Result: <span class="code">tailMap: {Sara=5, Jeff=4}</span></p>
        </li>

        <li>
            <p>Get all objects that come before the object with the key "<em>Nick</em>":</p>

            <pre class='language-java line-numbers'><code>
System.out.println("headMap: " + headMap);
 Map&lt;String, Integer&gt; headMap = map.headMap("Nick");
</code></pre>
         	
            <p>Result: <span class="code">headMap: {Anthony=5}</span></p>
        </li>

        <li>
            <p>Get all objects that come after the object with the key "<em>Oliver</em>" and come before the object with the key "<em>Sara</em>":</p>

            <pre class='language-java line-numbers'><code>
Map&lt;String, Integer&gt; subMap = map.subMap("Oliver", "Sara");	
System.out.println("subMap: " + subMap);
</code></pre>

            <p>Result: <span class="code">subMap: {Oliver=5, Roxy=5}</span></p>
        </li>

    </ol>

    <h2>Comparison of HashMap and SortedMap/TreeMap</h2>

    <p>Let's talk about how the elements are ordered and stored:</p>

    <ul>
        <li><p>Since <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> does not give us any guarantees about order when iterating, the order may completely change when new elements are added.</p></li>

        <li><p>In <span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span>, the order is based on the "natural ordering" of the keys according to their <span class="code text-orange">compareTo()</span> method (or a <span class="text-neon"><span class="text-bold"><em>Comparator</em></span></span> that we provide). Also, don't forget that <span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span> implements the <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> interface, which contains methods that depend on this sort order.</p></li>
    </ul>

    <p>Now we turn to a consideration of performance and speed:</p>

    <ul>
        <li><p><span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> is a map based on hashing keys. It can insert and get elements in <span class="text-bold">O(1)</span>, constant time. To support this, the keys must implement <span class="code text-orange">hashCode()</span> and <span class="code text-orange">equals()</span>.</p></li>

        <li><p><span class="text-neon"><span class="text-bold"><em>TreeMap</em></span></span> is a tree-based map. Its insert and fetch operations take logarithmic time, i.e. <span class="text-bold">O(log n)</span>, which depends on the number of elements in the map. This is necessary so that the elements have some sort of comparison mechanism provided by either our key or an external Comparator. This mechanism determines the iteration order.</p></li>
    </ul>

    <p>And these factors help us decide which collections to use and when. </p>

    <p>If we need to store values in a certain order, the choice is obvious — we need a <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span>. Although it is a little slower than <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span>, it performs important tasks for us.</p>

    <p>As mentioned earlier, <span class="text-neon"><span class="text-bold"><em>SortedMap</em></span></span> can give us the first (or last) key, or value, or key-value pair in our map, regardless of when that value was added. The <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> implementation cannot do this.</p>

    <p>For example, consider a map with keys (students' names) and values (their grades). Let's say we want to work with a list in reverse alphabetical order.</p>

    <p>1.</p>

    <pre class='language-java line-numbers'><code>
SortedMap&lt;String, Integer&gt; sorted = new TreeMap&lt;String,Integer&gt;(Comparator.reverseOrder());
sorted.put("Anthony", 5);
sorted.put("Sara", 5);
sorted.put("Jeff", 4);

String firstKeyFromSortedMapVariant = sorted.firstKey();

Integer markFromSortedMap = sorted.get(firstKeyFromSortedMapVariant);
System.out.println(firstKeyFromSortedMapVariant + " - " + markFromSortedMap);
</code></pre>

    <p>2.</p>

    <pre class='language-java line-numbers'><code>
HashMap&lt;String, Integer&gt; hash = new HashMap&lt;String,Integer&gt;();
hash.put("Anthony", 5);
hash.put("Sara", 5);
hash.put("Jeff", 4);

SortedSet&lt;String&gt; keySetOfHashMap = new TreeSet&lt;String&gt;(Comparator.reverseOrder());
// Or sort manually, storing elements in an array or list (preserving the insertion order)
keySetOfHashMap.addAll(hash.keySet());
String firstKeyFromHashMapVariant = keySetOfHashMap.first();


Integer markFromHashMap = hash.get(firstKeyFromHashMapVariant);
System.out.println(firstKeyFromHashMapVariant + " - " + markFromHashMap);
</code></pre>

    <p>The example shows that using a <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> makes the task more complicated, since <span class="text-neon"><span class="text-bold"><em>HashMap</em></span></span> guarantees neither the order of storage nor the order of obtaining elements from the map.</p>