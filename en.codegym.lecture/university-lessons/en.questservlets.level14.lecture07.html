How to loosen coupling between software modules
<p>----------------------------------------</p>
Decomposition of our all Interfaces. Facade
<p>----------------------------------------</p>
<h2>8.1 Decomposition is everything</h2>
<p>For clarity, a picture from a good article "Decoupling of Object-Oriented Systems", illustrating the main points that will be discussed.</p><img data-max-width="800" data-id="583c2148-3bd5-4256-abdd-8f098bd4bd6d" alt="Decomposition" src="https://cdn.javarush.com/images/article/583c2148-3bd5-4256-abdd-8f098bd4bd6d/800.jpeg" style="width: 800px;">
<p>Do you still think that designing an application architecture is easy?</p>
<h2>8.2 Interfaces, implementation hiding</h2>
<p>The main principles for reducing the coupling of the system are the principles of OOP and the principle of Encapsulation + Abstraction + Polymorphism behind them.</p>
<p>That is why:</p>
<ul>
 <li><span class="text-green">Modules should be "black boxes" for each other (encapsulation)</span> . This means that one module should not “climb” into another module and know anything about its internal structure. Objects in one subsystem should not directly access objects in another subsystem.</li>
 <li><span class="text-user">Modules/subsystems should interact with each other only through interfaces</span> (that is, <strong>abstractions</strong> that do not depend on implementation details). Accordingly, each module must have a well-defined interface or interfaces for interacting with other modules.</li>
</ul>
<p><strong>The principle of "black box"</strong> (encapsulation) allows us to consider the structure of each subsystem independently of other subsystems. The module, which is a "black box", can be relatively freely changed. Problems can arise only at the junction of different modules (or a module and an environment).</p>
<p>And this interaction must be described in the most general (abstract) form, that is, in the form of an interface. In this case, the code will work the same with any implementation that conforms to the interface contract. It is this ability to work with different implementations (modules or objects) through a unified interface that is called polymorphism.</p>
<p>That is why <span class="text-green">Servlet is an interface</span> : the web container does not know anything about servlets, for it these are some objects that implement the Servlet interface and that's it. Servlets also know a little about the structure of the container. The Servlet interface is that contract, that standard, that minimum interaction that is needed to make Java web applications take over the world.</p>
<p><strong>Polymorphism</strong> is not at all the overriding of methods, as is sometimes mistakenly believed, but first of all, the interchangeability of modules / objects with the same interface or “one interface, many implementations”. To implement polymorphism, the inheritance mechanism is not needed at all. This is important to understand because <span class="text-red">inheritance in general should be avoided whenever possible</span> .</p>
<p>Thanks to <span class="text-green">interfaces and polymorphism,</span> it is precisely the ability to modify and extend the code without changing what is already written (Open-Closed Principle) is achieved.</p>
<p>As long as the interaction of modules is described exclusively in the form of interfaces and is not tied to specific implementations, you have the opportunity to absolutely “painlessly” for the system replace one module with any other that implements the same interface, as well as add a new one and thereby expand functionality.</p>
<p>It's like in the LEGO constructor - the interface standardizes the interaction and serves as a kind of connector where any module with a suitable connector can be connected.</p>
<p>The flexibility of the designer is ensured by the fact that we can simply replace one module or part with another with the same connectors (with the same interface), as well as add as many new parts as we like (at the same time, existing parts are not changed or altered in any way).</p>
<p>Interfaces allow you to build a simpler system, considering each subsystem as a whole and ignoring its internal structure. They allow modules to interact and at the same time know nothing about the internal structure of each other, thereby fully implementing the principle of minimal knowledge, which is the basis of loose coupling.</p>
<p>The more general/abstract the interfaces are defined and the less restrictions they impose on interaction, the more flexible the system. From here, one more of the principles of SOLID actually follows - the Interface <strong>Segregation Principle</strong> , which opposes “thick interfaces”.</p>
<p>He says that large, bulky interfaces should be broken down into smaller, more specific ones, so that clients of small interfaces (depending modules) only know about the methods they need to work with.</p>
<p>This principle is formulated as follows: “Clients should not depend on methods (be aware of methods) that they do not use” or “Many specialized interfaces are better than one universal one”.</p>
<p>It turns out that weak connectivity is provided only when the interaction and dependencies of modules are described only with the help of interfaces, that is, abstractions, without using knowledge about their internal structure and structure. And in fact, encapsulation is thus implemented. Plus, we have the ability to expand / change the behavior of the system by adding and using different implementations, that is, due to polymorphism. Yes, we again came to OOP - Encapsulation, Abstraction, Polymorphism.</p>
<h2>8.3 Facade: module interface</h2>
<p>Here an experienced programmer will ask: if the design is not at the level of objects that themselves implement the corresponding interfaces, but at the level of modules, then what is the implementation of the module interface?</p>
<p>Answer: speaking in the language of design patterns, then a special object can be responsible for the implementation of the module interface - <strong>Facade</strong> . If you're calling methods on an object that contains the Gateway suffix (for example, MobileApiGateway), then it's most likely a facade.</p>
<p><span class="text-green"><strong>A facade is an interface object</strong> that accumulates a high-level set of operations for working with a certain subsystem, hiding its internal structure and true complexity behind it</span> . Provides protection against changes in the subsystem implementation. Serves as a single entry point - "you kick the facade, and he knows who needs to be kicked in this subsystem in order to get what he needs."</p>
<p>You have just been introduced to one of the most important design patterns that allows you to use the concept of interfaces when designing modules and thereby loosen their coupling - "Facade".</p>
<p>In addition, "Facade" makes it possible to work with modules in the same way as with ordinary objects and apply all the useful principles and techniques that are used in the design of classes when designing modules.</p><img data-max-width="1024" data-id="6ab91681-8155-4b59-b05f-7f01cdef7d10" alt="Facade: module interface" src="https://cdn.javarush.com/images/article/6ab91681-8155-4b59-b05f-7f01cdef7d10/1024.jpeg" style="width: 1024px;">
<p><strong>Note</strong> : Although most programmers understand the importance of interfaces when designing classes (objects), it seems that many discover the idea of ​​using interfaces at the module level themselves.</p>