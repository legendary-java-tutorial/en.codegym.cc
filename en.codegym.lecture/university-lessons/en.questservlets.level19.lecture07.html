Locks: lock access to resources
<p>----------------------------------------</p>
ReentrantLock. Synchronizer.
<p>----------------------------------------</p>
4" data-id="ee2cd199-b06a-4310-93c0-67f113b8ba93" alt="" src="https://cdn.javarush.com/images/article/ee2cd199-b06a-4310-93c0-67f113b8ba93/1024.jpeg" style="width: 1024px;">
<p><span class="text-neon"><span class="text-bold"><em>Condition</em></span></span> - applying conditions in locks allows you to achieve control over the management of access to streams. The lock condition is an object of the<span class="text-neon"><span class="text-bold"><em> Condition</em></span></span> interface from the<strong>java.util.concurrent.locks</strong>. <span class="text-neon"><span class="text-bold"><em>Using Condition</em></span></span> objectsis in many ways similar to using the<span class="code text-orange">wait</span>/<span class="code text-orange">notify</span>/<span class="code text-orange">notifyAll</span><span class="code"><span class="text-green"> methods of the Object</span></span> class, which were discussed in one of the previous topics.</p>
<p><span class="text-neon"><span class="text-bold"><em>Lock</em></span></span> is an interface from<strong>the lock framework</strong>that provides a flexible approach to restricting access to resources/blocks compared to synchronized. When using several locks, the order of their release can be arbitrary, plus it can also be configured. There is also the possibility to handle the situation when the lock is already captured.</p>
<p><span class="code"><span class="text-green">ReentrantLock</span></span> is one of the implementations of the<span class="text-neon"><span class="text-bold"><em> Lock</em></span></span><span class="code"><span class="text-green"> interface, the ReentrantLock</span></span> class. It allows the same thread to call the lock method, even if it has called it before, without releasing the lock.</p>
<p><span class="code"><span class="text-green">The ReentrantLock</span></span> class , in addition to the methods of <span class="text-neon"><span class="text-bold"><em>the Lock</em></span></span> interface , has a factory method <span class="code text-orange">newCondition()</span> . This method returns an object<mark class="green">Condition</mark>, which allows you to add the current thread to the wait set of the given object<mark class="green">Condition</mark>.</p>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Lock</span> R_LOCK <span class="token operator">=</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
R_LOCK<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
   <span class="token comment">//some action happens here</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
   R_LOCK<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><span class="text-neon"><span class="text-bold"><em>ReadWriteLock</em></span></span> is an interface for creating read/write locks. Locks are extremely useful when a system has a lot of reads and few writes.</p>
<p><span class="code"><span class="text-green">ReentrantReadWriteLock</span></span> - used in multi-threaded services and caches, has a nice performance boost compared to synchronized blocks. In fact, the class works in 2 mutually exclusive modes: many readers read data in parallel and when only 1 writer writes data.</p>
<p>ReentrantReadWriteLock.ReadLock - read lock for readers, obtained via readWriteLock.readLock().</p>
<p>ReentrantReadWriteLock.WriteLock - write lock for writers, obtained via readWriteLock.writeLock().</p>
<h2>Synchronizer</h2><img data-max-width="512" data-id="cb9ae844-7dce-459b-b8af-55a1830c5fb1" alt="" src="https://cdn.javarush.com/images/article/cb9ae844-7dce-459b-b8af-55a1830c5fb1/512.jpeg" style="width: 512px;">
<p><span class="code"><span class="text-green">AbstractOwnableSynchronizer</span></span> is the base class responsible for building synchronization mechanisms. Contains a getter/setter to remember and read an exclusive stream that can operate on your data.</p>
<p><span class="code"><span class="text-green">AbstractQueuedSynchronizer</span></span> is the base class for the synchronization mechanism in FutureTask, CountDownLatch, Semaphore, ReentrantLock, ReentrantReadWriteLock. It is also used when creating new synchronization mechanisms that rely on a single and atomic int value.</p>
<p><span class="code"><span class="text-green">AbstractQueuedLongSynchronizer</span></span> is a variant of<span class="code"><span class="text-green"> AbstractQueuedSynchronizer</span></span> that supports the atomic long value.</p>