s you already know, the JVM runs Java programs within itself. Like any virtual machine, it has its own memory organization system.</p>
<p>The internal memory layout indicates how your Java application works. In this way, bottlenecks in the operation of applications and algorithms can be identified. Let's see how it works.</p><img data-max-width="800" data-id="1180008a-b863-4007-b14b-10c0a106ecb8" alt="Understanding Memory in the JVM" src="https://cdn.javarush.com/images/article/1180008a-b863-4007-b14b-10c0a106ecb8/800.jpeg" style="width: 800px;">
<p><strong>Important! </strong>The original Java model was not good enough, so it was revised in Java 1.5. This version is used to this day (Java 14+).</p>
<h2>Thread stack</h2>
<p>The Java memory model used internally by the JVM divides memory into thread stacks and heaps. Let's look at the Java memory model, logically divided into blocks:</p><img data-max-width="512" data-id="06c9cf70-8f47-463d-b6bd-e19ae1f5d72a" alt="Thread stack" src="https://cdn.javarush.com/images/article/06c9cf70-8f47-463d-b6bd-e19ae1f5d72a/512.jpeg" style="width: 512px;">
<p><strong>All threads</strong> running in the JVM have <strong>their own stack</strong> . The stack, in turn, holds information about which methods the thread has called. I will call this the “call stack”. The call stack resumes as soon as the thread executes its code.</p>
<p>The thread's stack contains <strong>all the local variables</strong> required to execute methods on the thread's stack. A thread can only access its own stack. Local variables are not visible to other threads, only to the thread that created them. In a situation where two threads are executing the same code, they both create their own local variables. Thus, each thread has its own version of each local variable.</p>
<p>All local variables of primitive types ( <span class="text-orange">boolean</span> , <span class="text-orange">byte</span> , <span class="text-orange">short</span> , <span class="text-orange">char</span> , <span class="text-orange">int</span> , <span class="text-orange">long</span> , <span class="text-orange">float</span> , <span class="text-orange">double</span> ) are stored entirely on the thread stack and are not visible to other threads. One thread can pass a copy of a primitive variable to another thread, but cannot share a primitive local variable.</p>
<h2>Heap</h2>
<p>The heap contains all the objects created in your application, regardless of which thread created the object. This includes wrappers of primitive types (for example, <span class="text-orange">Byte</span> , <span class="text-orange">Integer</span> , <span class="text-orange">Long</span> , and so on). It doesn't matter if the object was created and assigned to a local variable or created as a member variable of another object, it is stored on the heap.</p>
<p>Below is a diagram that illustrates the call stack and local variables (they are stored on stacks) as well as objects (they are stored on the heap):</p><img data-max-width="800" data-id="7b8ec0e5-49eb-4a16-b473-7462cbbc4065" alt="Heap" src="https://cdn.javarush.com/images/article/7b8ec0e5-49eb-4a16-b473-7462cbbc4065/800.jpeg" style="width: 800px;">
<p>In the case where the local variable is of a primitive type, it is stored on the thread's stack.</p>
<p>A local variable can also be a reference to an object. In this case, the reference (local variable) is stored on the thread stack, but the object itself is stored on the heap.</p>
<p>An object contains methods, these methods contain local variables. These local variables are also stored on the thread stack, even if the object that owns the method is stored on the heap.</p>
<p>An object's member variables are stored on the heap along with the object itself. This is true both when the member variable is of a primitive type and when it is an object reference.</p>
<p>Static class variables are also stored on the heap along with the class definition.</p>
<h2>Interaction with objects</h2>
<p>Objects on the heap can be accessed by all threads that have a reference to the object. If a thread has access to an object, then it can access the object's variables. If two threads call a method on the same object at the same time, they will both have access to the object's member variables, but each thread will have its own copy of the local variables.</p><img data-max-width="800" data-id="130d32a3-c025-4f2b-9a40-616ba1fd2080" alt="Interaction with objects (heap)" src="https://cdn.javarush.com/images/article/130d32a3-c025-4f2b-9a40-616ba1fd2080/800.jpeg" style="width: 800px;">
<p>Two threads have a set of local variables.<mark class="user">Local Variable 2</mark>points to a shared object on the heap (<mark class="green">Object 3</mark>). Each of the threads has its own copy of the local variable with its own reference. Their references are local variables and are therefore stored on thread stacks. However, two different references point to the same object on the heap.</p>
<p>Please note that the general<mark class="green">Object 3</mark>has links to<mark class="green">Object 2</mark>And<mark class="green">Object 4</mark>as member variables (shown by arrows). Through these links, two threads can access<mark class="green">Object 2</mark>And<mark class="green">Object</mark>4.</p>
<p>The diagram also shows a local variable (<mark class="user">local variable 1</mark>from <span class="code text-orange">methodTwo</span> ). Each copy of it contains different references that point to two different objects (<mark class="green">Object 1</mark>And<mark class="green">Object 5</mark>) and not the same one. Theoretically, both threads can access both<mark class="green">Object 1</mark>, so to<mark class="green">Object 5</mark>if they have references to both of these objects. But in the diagram above, each thread only has a reference to one of the two objects.</p>
<h2>An example of interaction with objects</h2>
<p>Let's see how we can demonstrate the work in code:</p>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySomeRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> localOne <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token class-name">Shared</span> localTwo <span class="token operator">=</span> <span class="token class-name">Shared</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>

        <span class="token comment">//... do something with local variables</span>

        <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">two</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Integer</span> localOne <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token comment">//... do something with local variables</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" line-numbers language-java" tabindex="0"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span><code class=" language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Shared</span> <span class="token punctuation">{</span>

    <span class="token comment">// store an instance of our object in a variable</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Shared</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// member variables pointing to two objects on the heap</span>

    <span class="token keyword">public</span> <span class="token class-name">Integer</span> object2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> object4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><span class="code text-orange">The run()</span> method calls the <span class="code text-orange">one()</span> method , and <span class="code text-orange">one()</span> in turn calls <span class="code text-orange">two()</span> .</p>
<p><span class="code text-orange">The one()</span> method declares a primitive local variable (<mark class="user">localOne</mark>) of type <span class="text-orange">int</span> and a local variable (<mark class="user">localTwo</mark>), which is a reference to an object.</p>
<p>Each thread executing <span class="code text-orange">the one()</span> method will create its own copy<mark class="user">localOne</mark>And<mark class="user">localTwo</mark>in your stack. Variables<mark class="user">localOne</mark>will be completely separated from each other, being on the stack of each thread. One thread cannot see what changes another thread makes to its copy<mark class="user">localOne</mark>.</p>
<p>Each thread executing the <span class="code text-orange">one()</span> method also creates its own copy<mark class="user">localTwo</mark>. However, two different copies<mark class="user">localTwo</mark>end up pointing to the same object on the heap. The fact is that<mark class="user">localTwo</mark>points to the object referenced by the static variable<mark class="user">instance</mark>. There is only one copy of a static variable, and that copy is stored on the heap.</p>
<p>So both copies<mark class="user">localTwo</mark>end up pointing to the same <span class="code"><span class="text-green">Shared</span></span> instance . <span class="code"><span class="text-green">The Shared</span></span> instance is also stored on the heap. It matches<mark class="green">Object 3</mark>in the diagram above.</p>
<p>Note that the <span class="code"><span class="text-green">Shared</span></span> class also contains two member variables. The member variables themselves are stored on the heap along with the object. Two member variables point to two other objects<mark class="green">Integer</mark>. These integer objects correspond to<mark class="green">Object 2</mark>And<mark class="green">Object 4</mark>on the diagram.</p>
<p>Also note that the <span class="code text-orange">two()</span> method creates a local variable named<mark class="user">localOne</mark>. This local variable is a reference to an object of type <span class="text-orange">Integer</span> . The method sets the link<mark class="user">localOne</mark>to point to a new <span class="text-orange">Integer</span> instance . The link will be stored in its copy<mark class="user">localOne</mark>for each thread. Two <span class="text-orange">Integer</span> instances will be stored on the heap, and because the method creates a new <span class="text-orange">Integer</span> object each time it is executed, the two threads executing this method will create separate <span class="text-orange">Integer</span> instances . They match<mark class="green">Object 1</mark>And<mark class="green">Object 5</mark>in the diagram above.</p>
<p>Notice also the two member variables in the <span class="code"><span class="text-green">Shared</span></span> class of type <span class="text-orange">Integer</span> , which is a primitive type. Because these variables are member variables, they are still stored on the heap along with the object. Only local variables are stored on the thread stack.</p>