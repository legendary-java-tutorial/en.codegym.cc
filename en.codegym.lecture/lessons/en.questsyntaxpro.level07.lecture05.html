<h2>1. Company history</h2>
<p>I want to tell you a story that demonstrates how <span class="term">OOP</span> helps fight with the complexity of large systems. This is necessary for you to understand the purpose of <span class="term">OOP</span>.</p>
<p>Once upon a time there was a small company that provided intergalactic shipping services...</p>
<p>Let's call it Galaxy Rush. It employed 5 people. One worked in finance, the second worked in a warehouse, the third did the deliveries, the fourth handled advertising, and the fifth managed the whole enterprise.</p>
<p>They were very hard workers and succeeded at everything. The company had a good reputation and made a lot of money. But every year there were more and more orders, so the boss had to hire additional employees. Several more for the warehouse, several more for deliveries, one more for finance, and an additional advertising expert to expand the company's market share.</p>
<p><span class="text-red">And that's when the problems started. There were <strong>more people</strong>, and they <strong>began to get in each other's way.</strong></span></p>
<p>The marketer spends drains the bank account on a new advertising campaign, so <span class="text-orange">there is no money to purchase products that urgently need to be shipped.</span></p>
<p>The warehouse has 10 brand-new hyper drives that get shipped to a client once a month. One courier flew in and took away a hyper drive for a different client, causing the regular order for 10 hyper drives to be delayed by a month. <span class="text-orange">The first courier simply didn't know about the other order being filled by that the second courier.</span></p>
<p>The new assistant manager sends a courier away on a spaceship to purchase more goods. Meanwhile, <span class="text-orange">everyone else waits for an available spaceship to appear.</span> There are tons of urgent deliveries, but this assistant only oversees procurement and <strong>is trying to do her job well.</strong> <span class="text-green">The better an employee performs his duties, the more he interferes with the work of others.</span></p>
<p>Analyzing the situation, the boss realizes that important resources like the spaceship, cash and products are not being used optimally. Instead, they are subject to the rule "you snooze, you lose". Any employee could take a resource that everyone else needs for their work, thereby endangering the other employees and the company as a whole.</p>
<p>Something had to be done, so <span class="text-green">the boss decided to divide the monolithic company into a few departments.</span> He created a shipping department, a marketing department, a procurement department, a finance department, and an inventory department. No longer could anyone simply take the spaceship. The head of the shipping department received all information about the deliveries and issued the ship to the courier with the most profitable order. Additionally, the warehouse didn't allow couriers to simply take any goods they wanted. Instead, picking products from the warehouse became a controlled process. The finance department wouldn't release funds for a marketing campaign if it knew that there would be a purchase soon. Each department had one public face â€” the department head. <span class="text-red">Each department's internal structure was its own business. </span>If a courier wanted to get products, she went to the warehouse manager, not to the warehouse. If a new order came in, it was received by the head of the shipping department (<code>public-facing representative</code>) and not by a courier (<code>someone not authorized to interact with the other departments</code>).</p>
<p>In other words, <span class="text-green">the boss consolidated the resources and actions involving resources into groups (departments)</span>, <span class="text-orange">and also forbade others to interfere with departments' internal structures.</span> <span class="text-viola">Interdepartmental interactions had to go through a specific person.</span></p>
<p>From the point of view of <span class="term">OOP</span>, this is nothing more than <span class="text-green">dividing the program into objects. A monolithic program of methods and variables becomes a program comprised of objects. </span>And the objects have variables and methods.</p>
<p><span class="text-user">The problem was that <span class="text-red">any employee could work with any resource and give commands to any other employee, all without oversight or controls. </span></span><span class="text-user">We imposed a small restriction, but achieved more order. And we were also able to better control everything.</span></p>
<p>This is divide-and-conquer in its purest form.</p>
<hr>
<h2>2. How programs are created</h2>
<p>I want to touch upon one more important point that reveals another advantage of <span class="term">OOP</span>. Do you see that programs are more like animals than buildings? <strong><span class="text-green">They are not built. They are grown. </span></strong><span class="text-green">Development is constant change.</span> In construction, you can have a good plan and follow it with precision. This is not the case with software development.</p>
<p>Very often in programming, you can't do something the way you originally intended and must rework a lot. Customer requirements change even more often.</p>
<p>But what if the customer provided a very precise specification? That makes things even worse. Take a look at what happens with the product over time.</p>
<p><span class="text-orange">The product's success will lead the customer to want to release a new version, and then another and another. </span>And, of course, all you need to do is add "small changes" to the existing product. <span class="text-green">So you can see product development is a sequence of constant changes. </span>Only the time scale is different. A new version can be released once a week, once a month or once every six months.</p>
<p>And what conclusion can we draw from all this? <span class="text-red">The product's internal structure needs to be maintained in a way that allows significant (and minor) changes to be made with minimal reworking.</span></p>
<p><strong>Object cohesion</strong></p>
<p><span class="text-user">But doing that is more difficult than deciding to do it. </span>We already said that a program consists of objects that interact with each other. Let's draw all our program's objects on the board, representing them by points. And let's draw arrows from each object (point) to all the other objects (points) that it interacts with.</p>
<p>Now we'll combine the objects (points) into groups. Points should be grouped if the connections between them are much more intense than those with other points. If most of the arrows from a point go to others points in its own group, then the groups were formed correctly. We say that the points within a group have <strong>high cohesion</strong> while points in different groups have lower cohesion.</p>
<p><strong>Loose-coupling principle</strong></p>
<p>There is a "principle of loose coupling". A program is divided into several parts, which are often layers. The logic of these layers/parts is tightly coupled to their internal structure and very loosely coupled to other layers/parts. <span class="text-orange">Interactions between layers are usually very regulated. One layer might refer to the second layer and use only a small subset of its classes. <span class="text-user">This is the principle of "dividing the company into departments" we saw earlier, but on a larger scale.</span></span></p>
<p>The result is that we can reorganize a department as needed to increase its effectiveness and we can hire even more people for the department, and <span class="text-red">as long as we don't change the protocol of interaction with our other departments, then all the changes made will remain local. </span>Nobody has to relearn anything. You don't have to rework the entire system. Each department can do this kind of internal optimization if the mechanisms for interdepartmental interaction are well chosen.</p>
<p>Chosen well. But what if they are not chosen well? Then the <strong>capacity for change</strong> is quickly exhausted and you'll have to redo the entire system. This has to be done from time to time. You can't predict the future, but you can keep the number of redos to a minimum.</p>
<p><strong>Principle of abstraction</strong></p>
<p>Choosing how departments are structured and how they interact is the "<strong>principle of abstraction</strong>". In programming, it is used to determine best way to break a program into constituent parts and how those parts should interact. We can reapply the principle, dividing the resulting parts into parts, until we've broken the program down into individual classes.</p>
<p><span class="text-user">Hiding the internal structure of these parts and strictly limiting interactions with other parts is <strong>encapsulation</strong>.</span> <span class="text-green">Encapsulation and abstraction are cornerstones of <span class="term">OOP</span>.</span> A good program must follow these two principles. In the future, we will look at the rest of the principles and explore what benefits they provide.</p>